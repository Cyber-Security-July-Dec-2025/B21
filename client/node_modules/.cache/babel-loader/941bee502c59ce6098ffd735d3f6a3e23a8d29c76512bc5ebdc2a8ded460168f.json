{"ast":null,"code":"// crypto.js - WebCrypto helpers\n\nexport function hexToArrayBuffer(hex) {\n  if (!hex) return new ArrayBuffer(0);\n  const clean = hex.replace(/\\s+/g, '');\n  const len = clean.length / 2;\n  const u8 = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    u8[i] = parseInt(clean.substr(i * 2, 2), 16);\n  }\n  return u8.buffer;\n}\nexport function arrayBufferToHex(buffer) {\n  const bytes = new Uint8Array(buffer);\n  const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');\n  return hex;\n}\nexport function arrayBufferToBase64(arrayBuffer) {\n  const bytes = new Uint8Array(arrayBuffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\nexport function base64ToArrayBuffer(base64) {\n  const binary = atob(base64);\n  const len = binary.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n\n// Generate AES-256-GCM key\nexport async function generateAESKey() {\n  const key = await crypto.subtle.generateKey({\n    name: 'AES-GCM',\n    length: 256\n  }, true, ['encrypt', 'decrypt']);\n  return key;\n}\n\n// Export AES raw bytes (ArrayBuffer)\nexport async function exportAESRaw(key) {\n  return await crypto.subtle.exportKey('raw', key);\n}\n\n// Import raw AES key from ArrayBuffer\nexport async function importAESRaw(raw) {\n  return await crypto.subtle.importKey('raw', raw, {\n    name: 'AES-GCM'\n  }, true, ['encrypt', 'decrypt']);\n}\n\n// Import RSA public key (HEX of SPKI DER)\nexport async function importRSAPublicKeyHex(pubHex) {\n  const spki = hexToArrayBuffer(pubHex);\n  return await crypto.subtle.importKey('spki', spki, {\n    name: 'RSA-OAEP',\n    hash: 'SHA-256'\n  }, false, ['encrypt']);\n}\n\n// ✅ Import RSA public key (Base64 of SPKI DER)\nexport async function importRSAPublicKeyBase64(pubBase64) {\n  const spki = base64ToArrayBuffer(pubBase64);\n  return await crypto.subtle.importKey('spki', spki, {\n    name: 'RSA-OAEP',\n    hash: 'SHA-256'\n  }, false, ['encrypt']);\n}\n\n// Import RSA private key (HEX of PKCS8 DER)\nexport async function importRSAPrivateKeyHex(privHex) {\n  const pkcs8 = hexToArrayBuffer(privHex);\n  return await crypto.subtle.importKey('pkcs8', pkcs8, {\n    name: 'RSA-OAEP',\n    hash: 'SHA-256'\n  }, false, ['decrypt']);\n}\n\n// RSA encrypt raw AES key (ArrayBuffer) -> ArrayBuffer\nexport async function rsaEncrypt(publicKey, rawAESArrayBuffer) {\n  return await crypto.subtle.encrypt({\n    name: 'RSA-OAEP'\n  }, publicKey, rawAESArrayBuffer);\n}\n\n// RSA decrypt -> raw AES bytes\nexport async function rsaDecrypt(privateKey, encrypted) {\n  return await crypto.subtle.decrypt({\n    name: 'RSA-OAEP'\n  }, privateKey, encrypted);\n}\n\n// Compute SHA-256 digest of an ArrayBuffer -> ArrayBuffer(32 bytes)\nexport async function sha256(arrayBuffer) {\n  return await crypto.subtle.digest('SHA-256', arrayBuffer);\n}\n\n// AES-GCM encrypt: returns {ciphertext: ArrayBuffer, iv: Uint8Array}\nexport async function aesGcmEncrypt(aesKey, dataArrayBuffer) {\n  const iv = crypto.getRandomValues(new Uint8Array(12)); // recommended 12 bytes\n  const ciphertext = await crypto.subtle.encrypt({\n    name: 'AES-GCM',\n    iv\n  }, aesKey, dataArrayBuffer);\n  return {\n    ciphertext,\n    iv\n  };\n}\n\n// AES-GCM decrypt\nexport async function aesGcmDecrypt(aesKey, ivUint8, ciphertextArrayBuffer) {\n  return await crypto.subtle.decrypt({\n    name: 'AES-GCM',\n    iv: ivUint8\n  }, aesKey, ciphertextArrayBuffer);\n}","map":{"version":3,"names":["hexToArrayBuffer","hex","ArrayBuffer","clean","replace","len","length","u8","Uint8Array","i","parseInt","substr","buffer","arrayBufferToHex","bytes","Array","from","b","toString","padStart","join","arrayBufferToBase64","arrayBuffer","binary","byteLength","String","fromCharCode","btoa","base64ToArrayBuffer","base64","atob","charCodeAt","generateAESKey","key","crypto","subtle","generateKey","name","exportAESRaw","exportKey","importAESRaw","raw","importKey","importRSAPublicKeyHex","pubHex","spki","hash","importRSAPublicKeyBase64","pubBase64","importRSAPrivateKeyHex","privHex","pkcs8","rsaEncrypt","publicKey","rawAESArrayBuffer","encrypt","rsaDecrypt","privateKey","encrypted","decrypt","sha256","digest","aesGcmEncrypt","aesKey","dataArrayBuffer","iv","getRandomValues","ciphertext","aesGcmDecrypt","ivUint8","ciphertextArrayBuffer"],"sources":["C:/Users/new/secure-file-vault/client/src/utils/crypto.js"],"sourcesContent":["// crypto.js - WebCrypto helpers\r\n\r\nexport function hexToArrayBuffer(hex) {\r\n  if (!hex) return new ArrayBuffer(0);\r\n  const clean = hex.replace(/\\s+/g, '');\r\n  const len = clean.length / 2;\r\n  const u8 = new Uint8Array(len);\r\n  for (let i = 0; i < len; i++) {\r\n    u8[i] = parseInt(clean.substr(i * 2, 2), 16);\r\n  }\r\n  return u8.buffer;\r\n}\r\n\r\nexport function arrayBufferToHex(buffer) {\r\n  const bytes = new Uint8Array(buffer);\r\n  const hex = Array.from(bytes, b => b.toString(16).padStart(2, '0')).join('');\r\n  return hex;\r\n}\r\n\r\nexport function arrayBufferToBase64(arrayBuffer) {\r\n  const bytes = new Uint8Array(arrayBuffer);\r\n  let binary = '';\r\n  for (let i = 0; i < bytes.byteLength; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return btoa(binary);\r\n}\r\n\r\nexport function base64ToArrayBuffer(base64) {\r\n  const binary = atob(base64);\r\n  const len = binary.length;\r\n  const bytes = new Uint8Array(len);\r\n  for (let i = 0; i < len; i++) {\r\n    bytes[i] = binary.charCodeAt(i);\r\n  }\r\n  return bytes.buffer;\r\n}\r\n\r\n// Generate AES-256-GCM key\r\nexport async function generateAESKey() {\r\n  const key = await crypto.subtle.generateKey(\r\n    { name: 'AES-GCM', length: 256 },\r\n    true,\r\n    ['encrypt', 'decrypt']\r\n  );\r\n  return key;\r\n}\r\n\r\n// Export AES raw bytes (ArrayBuffer)\r\nexport async function exportAESRaw(key) {\r\n  return await crypto.subtle.exportKey('raw', key);\r\n}\r\n\r\n// Import raw AES key from ArrayBuffer\r\nexport async function importAESRaw(raw) {\r\n  return await crypto.subtle.importKey('raw', raw, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);\r\n}\r\n\r\n// Import RSA public key (HEX of SPKI DER)\r\nexport async function importRSAPublicKeyHex(pubHex) {\r\n  const spki = hexToArrayBuffer(pubHex);\r\n  return await crypto.subtle.importKey(\r\n    'spki',\r\n    spki,\r\n    { name: 'RSA-OAEP', hash: 'SHA-256' },\r\n    false,\r\n    ['encrypt']\r\n  );\r\n}\r\n\r\n// ✅ Import RSA public key (Base64 of SPKI DER)\r\nexport async function importRSAPublicKeyBase64(pubBase64) {\r\n  const spki = base64ToArrayBuffer(pubBase64);\r\n  return await crypto.subtle.importKey(\r\n    'spki',\r\n    spki,\r\n    { name: 'RSA-OAEP', hash: 'SHA-256' },\r\n    false,\r\n    ['encrypt']\r\n  );\r\n}\r\n\r\n// Import RSA private key (HEX of PKCS8 DER)\r\nexport async function importRSAPrivateKeyHex(privHex) {\r\n  const pkcs8 = hexToArrayBuffer(privHex);\r\n  return await crypto.subtle.importKey(\r\n    'pkcs8',\r\n    pkcs8,\r\n    { name: 'RSA-OAEP', hash: 'SHA-256' },\r\n    false,\r\n    ['decrypt']\r\n  );\r\n}\r\n\r\n// RSA encrypt raw AES key (ArrayBuffer) -> ArrayBuffer\r\nexport async function rsaEncrypt(publicKey, rawAESArrayBuffer) {\r\n  return await crypto.subtle.encrypt({ name: 'RSA-OAEP' }, publicKey, rawAESArrayBuffer);\r\n}\r\n\r\n// RSA decrypt -> raw AES bytes\r\nexport async function rsaDecrypt(privateKey, encrypted) {\r\n  return await crypto.subtle.decrypt({ name: 'RSA-OAEP' }, privateKey, encrypted);\r\n}\r\n\r\n// Compute SHA-256 digest of an ArrayBuffer -> ArrayBuffer(32 bytes)\r\nexport async function sha256(arrayBuffer) {\r\n  return await crypto.subtle.digest('SHA-256', arrayBuffer);\r\n}\r\n\r\n// AES-GCM encrypt: returns {ciphertext: ArrayBuffer, iv: Uint8Array}\r\nexport async function aesGcmEncrypt(aesKey, dataArrayBuffer) {\r\n  const iv = crypto.getRandomValues(new Uint8Array(12)); // recommended 12 bytes\r\n  const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, dataArrayBuffer);\r\n  return { ciphertext, iv };\r\n}\r\n\r\n// AES-GCM decrypt\r\nexport async function aesGcmDecrypt(aesKey, ivUint8, ciphertextArrayBuffer) {\r\n  return await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivUint8 }, aesKey, ciphertextArrayBuffer);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}